# Cursor Context (Backend, Spring Boot + Go/Rust, High Perf/Security)

## 目标

在高性能与高安全约束下，构建“可演进、可测试、可维护、可观测”的后端系统。后端存在两类项目形态：

- **Spring Boot 单体后端**（独立项目）
- **Go + Rust 协同后端**（独立项目）

## 架构与分层规范（强制）

- 依赖方向只允许由外向内：Controller/Adapter -> UseCase/Service -> Domain -> Infrastructure。
- 禁止面条代码，必须显式定义 DTO/VO/Request/Response/Domain Model。
- Controller 仅做编排、校验、权限验证与异常映射，业务逻辑必须在 UseCase/Service 层。
- Domain 不允许依赖框架与基础设施。

## 接口契约（强制）

- API 必须 contract-first（OpenAPI/Proto），前后端以契约为唯一事实源。
- REST 或 Finder API 统一风格，命名、分页、错误码必须一致。
- 变更必须具备版本管理策略与向后兼容策略。

## 架构模式池（建议）

- 事件驱动架构：异步解耦、削峰填谷、可扩展性增强。
- CQRS：读写分离，复杂业务场景优先评估。
- 插件化/可扩展架构：核心与扩展隔离，避免核心被侵蚀。

## 服务间通信契约规范（OpenAPI / Proto）

### OpenAPI（HTTP/REST/Finder）

- 以 `openapi.yaml`/`openapi.json` 作为唯一事实源，禁止手写分散文档。
- 统一路径命名：资源名用复数，层级表达关系，避免动词堆叠。
- 统一响应结构：`data` / `error` / `traceId`。
- 错误码必须可枚举，并与 HTTP 状态码做一对一映射。
- 分页约定固定参数名与返回结构（如 `page` / `size` / `total` / `items`）。
- 版本策略必须明确（路径版本或 Header 版本），废弃字段要标记 deprecate。
- 安全方案写入契约（Auth header、token 类型、过期规则）。

### Proto（gRPC/内部服务）

- `package` 与 `service` 命名必须包含版本号（如 `v1`）。
- 字段编号一旦发布不得复用；新增字段只允许追加。
- 避免破坏性变更：优先新增字段，禁止删除或更改字段语义。
- 尽量使用明确的 `enum` 与 `oneof`，避免模糊字符串。
- 对外错误需转译为统一错误结构（与 HTTP 错误码对齐）。
- 需要跨语言时，必须提供生成脚本与版本锁定策略。

## 命名规范（强制）

- 变量名必须自解释，禁止无意义或歧义命名。
- 同类概念必须统一词汇（userId 与 accountId 不混用）。
- 不允许使用模糊字段名（如 author），必须明确语义（authorUsername/authorDisplayName/authorId）。

## Spring Boot 实践（默认要求）

- Service 层进行业务编排与事务控制；Repository 只做持久化。
- 统一异常映射与错误码，不允许抛出底层异常到外层。
- 校验放在 Request/DTO 层（参数规则、范围、格式）。
- 对外接口统一响应结构（data + error + traceId）。

## Go + Rust 协同实践（默认要求）

- 适用于高性能/低延迟或系统级组件（如队列、解析、重计算）。
- Go 负责并发与网络服务，Rust 负责性能关键或安全敏感模块。
- 服务间通信优先 gRPC，内部协议优先 Proto。
- 统一日志格式与错误码，对外暴露需转译为统一 API 错误结构。

## 数据与事务（强制）

- 事务边界清晰，避免跨层事务泄漏。
- 索引与查询必须有基准（Explain/Profiling）。
- 缓存策略必须明确一致性方式（TTL/Write-Through/Write-Back）。

## 高性能策略（必须）

- 接口级限流/熔断/超时/重试/幂等。
- 热点隔离与降级策略明确。
- 关键路径具备 P95/P99 指标与告警阈值。

## 高安全策略（必须）

- 最小权限与默认拒绝。
- 传输加密 + 存储加密 + 密钥轮换。
- 依赖审计、SBOM、供应链校验必须纳入 CI。
- 审计日志必须包含 actorId + traceId + action + result。

## 可靠性与韧性工程（必须）

- SLO/SLA 明确，关键路径必须有错误预算与告警策略。
- 超时/重试/熔断/隔离/降级必须成套出现，禁止单点优化。
- 重要服务必须具备故障演练与回滚策略。

## AI 原生能力（可选）

- LLM/RAG 接入需有安全与合规边界（敏感数据脱敏/隔离）。
- 需要模型评测与回归基线，避免质量漂移。
- AI 能力需具备可观测性（请求/成本/质量指标）。

## 性能/安全差异化约束（按项目类型）

### Spring Boot 单体后端

- 性能：连接池、线程池与超时必须显式配置；关键查询必须有索引基准。
- 性能：核心路径必须有缓存策略与降级策略。
- 安全：统一 Filter/Security Chain，鉴权与权限校验不可绕过。
- 安全：参数校验必须在入口层完成（DTO/Request），禁止隐式信任。

### Go + Rust 协同后端

- 性能：Go 负责并发网络服务，Rust 负责性能/安全敏感模块；P99 延迟预算明确。
- 性能：避免不必要拷贝与内存分配，热点路径必须基准测试。
- 安全：跨边界交互必须有输入校验与协议校验，避免不可信数据进入核心逻辑。
- 安全：mTLS/签名校验优先用于服务间通信，密钥轮换必须自动化。

## 观测性（默认要求）

- 日志/指标/链路追踪三件套。
- TraceId 贯穿入口到存储层。
- 关键业务事件需产生结构化日志。

## 架构注意事项补充（可扩展性与一致性）

### 常见根因
- 平台/存储查询能力不足，导致全量扫描 + 内存过滤/分页。
- 交付优先，接口层堆叠业务与重复逻辑。
- 响应式链路混入阻塞 IO（导入导出/文件写入）。
- 缺少数据规模假设与性能基线，问题被延后暴露。

### 方案选择（按规模/一致性）
- 列表/统计：小规模可全量扫；中规模需服务端过滤或索引表；大规模用预聚合/读写分离。
- 计数一致性：低并发可读改写+纠偏；中并发用乐观锁；高并发用原子计数或事件投影。
- 导入导出：小文件用专用线程池隔离；大文件用异步任务 + 流式处理。
- 接口层治理：重复逻辑多时抽 UseCase/Assembler，接口仅做入参/出参与路由。

### 设计阶段预防（必须）
- 明确数据规模上限、QPS 与响应目标，并写入文档。
- 设定数据访问规则：默认禁止全量扫；列表必须可扩展筛选。
- 计数类必须选定一致性策略（原子/乐观锁/事件投影三选一）。
- 阻塞任务必须隔离到专用线程池或后台任务。
- 最小测试集必须覆盖：权限、幂等、状态流转、导入/导出。

## 产出要求（Cursor 输出规范）

- 默认输出：架构建议 + 权衡理由 + 风险点 + 测试策略 + 文档建议。
- 代码输出：清晰目录结构 + 依赖关系说明 + 接口定义示例。
- API 输出：契约示例 + 错误码规范 + 版本策略。

## 检查清单（Review Checklist）

- 命名是否自解释且无歧义？
- 是否存在面条代码或缺失 DTO/VO？
- 依赖方向是否由外向内？
- 事务边界与一致性策略是否清晰？
- 是否具备限流/熔断/幂等/降级？
- 安全控制与审计是否完备？

# Cursor Context (Frontend, Rsbuild/Vite + Vue/Lit + SCSS)

## 目标
在高性能与高安全约束下，建立“可演进、可测试、可维护、可观测”的前端工程体系。前端构建工具允许 Rsbuild 或 Vite（按项目选型），样式最终必须统一由一个 SCSS 入口管理，允许少量 scoped。Vue 为主要组件技术栈，必要时使用 Lit + Shadow DOM 输出隔离样式表。

## 项目现状（简述）
- Rsbuild 已用于主 UI 构建，且开启 Sass 支持（`pluginSass()`）。
- Vite 已用于静态端构建（独立入口、独立输出目录）。
- 全局样式集中在 `src/styles/global.scss`，包含变量、mixins、基础布局与组件公共样式。

## 构建工具决策矩阵（必须遵守）
### 1) 仅使用 Rsbuild（适用场景）
- 插件型 UI、需要与现有 Rsbuild 生态一致。
- 强依赖 Rsbuild 的插件体系或配置抽象。
- 产物以主后台 UI 为主。

### 2) 仅使用 Vite（适用场景）
- 独立前端项目、静态站点或更轻量的构建需求。
- 产物需要快速 HMR、简化配置。
- 不依赖 Rsbuild 的插件工具链。

### 3) Rsbuild + Vite 并存（适用场景）
- 同一仓库内存在「主后台 UI」与「静态/公开端」或「独立子应用」。
- 需要不同的构建入口/输出路径。
- 两者严格隔离：不同入口、不同输出、不同路径别名。

## 构建规则（统一要求）
- 不允许一个入口同时被 Rsbuild 与 Vite 构建。
- 不允许输出目录冲突。
- 入口与产物必须在文档中明确（入口文件、输出路径、构建命令）。
- 构建命令必须可组合（如 build:all），但产物分层清晰。

## 架构模式补充（建议）

- 事件驱动 UI：复杂交互通过事件流解耦，避免深层级 props 链。
- 插件化/模块化：核心与扩展隔离，按需加载，避免全量编译。
- CQRS 思维：读写模型分离，UI 状态与提交状态各自管理。

## SCSS 统一入口规范（强制）
### 核心原则
- 所有全局布局、主题、通用组件样式必须通过**单一 SCSS 入口**聚合。
- 允许少量 scoped，仅用于组件内部细节（不允许承载布局与主题）。

### 推荐结构（示例）
```
src/styles/
  main.scss            # 唯一入口（必须）
  tokens/              # 颜色、字体、间距、z-index、阴影
  layout/              # 栅格、页面容器、布局工具类
  components/          # 公共组件（按钮、卡片、表单等）
  utilities/           # 辅助类、状态类、文本类
```

### 入口导入顺序（必须）
1) tokens
2) layout
3) components
4) utilities

### scoped 使用规则（必须）
- scoped 只允许写组件局部差异，不允许写通用布局/主题/复用样式。
- scoped 的选择器必须以组件根元素为起点，避免全局泄漏。

## Vue 组件样式规则（必须）
- 组件优先使用全局类名（来自 `main.scss`）。
- 组件内样式只做「局部修饰」与「结构微调」。
- 禁止在组件内重复定义全局 tokens（颜色、间距、字体）。
- 需要主题差异时，使用 CSS Variables（由全局 SCSS 定义）。

## Lit + Shadow DOM 样式规则（必须）
### 目标
通过 Shadow DOM 隔离样式，但仍统一主题与 tokens。

### 规则
- Shadow DOM 内样式必须来自**单一构建产物**（如 `shadow.css` 或内联 CSSStyleSheet）。
- 禁止 Shadow DOM 内部直接引用全局布局类。
- Shadow DOM 样式通过 CSS Variables 与全局主题同步。

### 推荐方式
- 使用独立 `shadow.scss` 生成 shadow 样式表。
- 在 Lit 组件中通过 `adoptedStyleSheets` 或 `unsafeCSS` 引入。
- 仅使用 `:host` / `:host-context` 做上下文控制。

## 命名与分层规范（强制）
- 变量名必须自解释，禁止无意义或歧义命名。
- 同类概念必须词汇一致（userId 与 accountId 不混用）。
- 必须定义 VO/DTO/Request/Response，禁止面条代码。
- 组件负责展示与交互，数据编排放在 Store/Service/Composables。

## 安全与性能（默认要求）
- 默认安全：最小权限、默认拒绝、统一错误码。
- 关键路径必须有可观测指标（P95/P99）。
- 性能策略：按需加载、缓存一致性、性能预算约束。

## 可靠性与韧性（必须）

- UI 需具备 Error Boundary/全局错误兜底，不能白屏。
- 请求层必须支持超时、重试与降级回退。
- 必须提供空态/错误态/离线态的视觉与交互规范。

## AI 协作与文档化（可选）

- 关键交互与状态流必须生成图（Mermaid/时序图）。
- Prompt 模板库与上下文规则需版本化管理。

## 产出要求（Cursor 输出规范）
- 默认输出：架构建议 + 权衡理由 + 风险点 + 测试策略 + 文档建议。
- 代码输出：清晰目录结构 + 依赖关系说明 + 接口定义示例。
- 样式输出：全局 SCSS 入口 + 组件 scoped 约束 + Lit Shadow 样式说明。

## 架构注意事项补充（跨端通用）
### 常见根因
- 平台查询能力受限，导致全量扫描 + 内存过滤。
- 交付优先，接口层堆叠过多业务逻辑与重复逻辑。
- 响应式链路混入阻塞 IO（CSV/文件写入）。
- 缺少数据规模与性能基线，问题被延后暴露。

### 方案选择（按规模/一致性）
- 列表/统计：小规模可全量扫；中规模需服务端过滤或索引表；大规模用预聚合/读写分离。
- 计数一致性：低并发可读改写+纠偏；中并发用乐观锁；高并发用原子计数或事件投影。
- 导入导出：小文件用专用线程池隔离；大文件用异步任务 + 流式处理。
- 接口层治理：重复逻辑多时抽应用层/Assembler，接口仅做入参/出参与路由。

### 设计阶段预防（必须）
- 明确数据规模上限、QPS 与响应目标，并写入文档。
- 设定数据访问规则：默认禁止全量扫；列表必须可扩展筛选。
- 计数类必须选定一致性策略（原子/乐观锁/事件投影三选一）。
- 阻塞任务必须隔离到专用线程池或后台任务。
- 最小测试集必须覆盖：权限、幂等、状态流转、导入/导出。

## 检查清单（Review Checklist）
- 命名是否自解释且无歧义？
- 是否存在面条代码或缺失 VO/DTO？
- 是否前后端分离且接口契约明确？
- 样式是否统一入口？scoped 是否仅用于局部？
- Shadow DOM 样式是否独立产出并与主题同步？
- 构建入口与输出是否隔离清晰？
